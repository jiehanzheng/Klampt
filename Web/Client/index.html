<!DOCTYPE html>
<html>
   <head>
      <title>Klampt Three.js app</title>
      <meta charset="UTF-8">

      <script src="bower_components/jquery/dist/jquery.min.js"></script>

      <link rel="stylesheet" type="text/css" href="bower_components/w2ui/w2ui-1.4.3.min.css" />
      <script type="text/javascript" src="bower_components/w2ui/w2ui-1.4.3.min.js"></script>

      <script src="bower_components/threejs/build/three.min.js"></script> 
      <script src="bower_components/threejs/examples/js/controls/TrackballControls.js"></script> 

      <script src="bower_components/stats.js/build/stats.min.js"></script>

      <script src="DaveWebsocket.js"></script> 
          
      <!--
      <link rel="stylesheet" href="CodeMirror-master/lib/codemirror.css">
      <link rel="stylesheet" href="CodeMirror-master/addon/hint/show-hint.css">
         
      <script src="CodeMirror-master/lib/codemirror.js"></script>
      <script src="CodeMirror-master/addon/hint/show-hint.js"></script>
      <script src="CodeMirror-master/mode/python/python.js"></script>
      -->
      
      <script src="bower_components/ace-builds/src-min-noconflict/ace.js"></script>
      <script src="bower_components/ace-builds/src-min-noconflict/ext-language_tools.js"></script>
   
   </head>
    
   <body style="margin: 0px;">
      <div id="myLayout" style="position: absolute; top: 0; right: 0; bottom: 0; left: 0;"></div>
   
            
      <script>
         //var stats = new Stats();
			//stats.showPanel( 0 );
			//document.body.appendChild( stats.dom );
         
         var scene = new THREE.Scene();
         //var camera = new THREE.PerspectiveCamera( 75, 1.0, 0.1, 1000 );
         var camera = new THREE.PerspectiveCamera( 45, 1.0, 0.1, 1000 );
         camera.position.z = 6;
         camera.position.y = 3;
   
         var renderer = new THREE.WebGLRenderer();  
         var loader = new THREE.ObjectLoader();
   
         var network; 
         var editor;
         var visPanel;
         var freeRun=false;
         var localStorageAvailable=false;
         var localStorage;
         var newBoilerplate=true;
         
         function storageAvailable()
         {
            try {
               localStorage = window['localStorage'],
                  x = '__storage_test__';
               localStorage.setItem(x, x);
               localStorage.removeItem(x);
               console.log("looks like local storage is setup");

               return true;
            }
            catch(e) {
               console.log("looks like storage is not setup: " + e);
               return false;
            }
         }        
         
        
         function sendBoilerPlate()
         {
            var boilerid=$('#boilerselctor').val();
            sendMessage("B"+boilerid);
         }
                          
         function doCodeSubmit()
         {
            var textArea=document.getElementById("myTextarea");
            textArea.value="> ";
             
            if(localStorageAvailable)
            {
             localStorage.setItem('KlamptStartingCode_'+$('#boilerselctor').val(), editor.getValue());           
            }

            if(newBoilerplate || !isConnected()) {
               console.log("Sending new boiler plate...");
               if(network) {
                  network.disconnect();
               }
               waitForDisconnection(5000,function() {
                  console.log("Actually sending new boiler plate message");
                  runConnected(function() {
                     sendBoilerPlate(); 
                     sendCode();     
                     requestAdvance();
                     newBoilerplate = false;
                  });
               });
            }
            else {
               console.log("No new boiler plate, just sending code");
               sendCode();     
               requestAdvance();
            }
            if(newBoilerplate) {
               console.log("Error sending boiler plate???");
            }
         }
         function requestStop()
         {
            freeRun=false;
         }
         //TODO: request interrupt of embedded python
         // http://stackoverflow.com/questions/1420957/stopping-embedded-python
         
         function requestAdvance()
         {
            if(!isConnected())
            {
               doCodeSubmit();
            }
            if(isConnected()) {
               sendMessage("A");
            }
         }
         function requestFreeRun()
         {
            requestAdvance();
            freeRun=true;
         }
         
         //the magic of AJAX
         //http://stackoverflow.com/questions/3567369/reading-server-side-file-with-javascript
         function loadFileToEditor(file_to_load)
         {
            
            console.log("Trying to load stub code "+file_to_load);
            $.ajax({
               url: file_to_load,
               async: true,   // asynchronous request? (synchronous requests are discouraged...)
               cache: false,   // with this, you can force the browser to not make cache of the retrieved data
               dataType: "text",  // jQuery will infer this, but you can set explicitly
               success: function( data, textStatus, jqXHR ) {
                  editor.getSession().setValue(data); 
               },
               error : function( jqXHR, textStatus, errorThrown ) {
                  console.log("Error loading stub code: "+textStatus)
                  editor.getSession().setValue(""); 
               }
            });
         }


         function serverChanged()
         {
            console.log("Server changed.");
            if(network) {
               network.disconnect();
            }
            newBoilerplate = true;
            requestStop();
         }

         function doRevertChanges()
         {
            if (confirm("Are you sure you want to discard ALL changes?") == true) {
              var boilerid=$('#boilerselctor').val();
              var file_to_load="Scenarios/code_"+boilerid+".py";
              loadFileToEditor(file_to_load);
              newBoilerplate = true;
              requestStop();
            }
         }
   
         function boilerPlateChanged()
         {
            var boilerid=$('#boilerselctor').val();
            var file_to_load="Scenarios/code_"+boilerid+".py";
         
            if(localStorageAvailable) //lets see if we have worked on this previously
            {
               var example1Text=localStorage.getItem('KlamptStartingCode_'+boilerid);
               if(example1Text!=null)
               {               
                  editor.getSession().setValue(example1Text);
               }
               else
               {
                  loadFileToEditor(file_to_load);
               }
            }
            else
               loadFileToEditor(file_to_load);
            newBoilerplate = true;
            requestStop();
         }   
         
         
     
         $( document ).ready(function() {
            console.log("page is ready, lets setup some stuff");
            console.log("first testing if local storage is available");
            localStorageAvailable=storageAvailable();
            console.log("  local storage test determined: " + localStorageAvailable);
 
            var pstyle = 'background-color: #F5F6F7; border: 1px solid #dfdfdf; padding: 5px;';
            $('#myLayout').w2layout({
               name: 'layout',
               panels: [
                  { type: 'top',  size: "5%", resizable: true, style: pstyle, content: '<button onclick="doCodeSubmit()">Reset</button><button onclick="requestAdvance()">Advance Frame</button><button onclick="requestFreeRun()">Run</button><button onclick="requestStop()">Stop</button> <div style=" width:20px;display:inline-block;" />Klampt Server URL:<select id="serverURL" onchange="serverChanged()"/><div style=" width:20px;display:inline-block;" /><select id="boilerselctor" onchange="boilerPlateChanged()"></select><button onclick="doRevertChanges()">Revert to Skeleton Code</button> <span style="float:right"> <a href="http://motion.pratt.duke.edu/klampt/pyklampt_docs/namespaces.html" target="_blank">Klamp&#39;t Python API Docs</a> <a href="kviz_docs.html" target="_blank">kviz module docs</a> </span> '},
                  { type: 'main', style: pstyle, content: '<div id="canvas" style="width:100%; height:100%; margin:0; padding:0"></div>' },
                  { type: 'preview', size: "15%", resizable: true, style: pstyle, content: '<textarea readonly id="myTextarea" style="background-color: black;color:white;width:100%;height:100%">> </textarea></div></div>' },
                  { type: 'right', size: '50%', resizable: true, style: pstyle, content: 
                    '<div id="editor" style="width:100%; height:100%; margin:0; padding:0"></div>' },               ]
            });

            function add_server(val,text) {
		$('#serverURL').append($('<option>', {value:val}).text(text));
            }
            add_server("ws://rapid-165.vm.duke.edu:1234","rapid-165");
            add_server("ws://rapid-174.vm.duke.edu:1234","rapid-174");
            add_server("ws://rapid-175.vm.duke.edu:1234","rapid-175");
            add_server("ws://rapid-176.vm.duke.edu:1234","rapid-176");
            //set a random server
            var $options = $('#serverURL').find('option'),
               random = ~~(Math.random() * $options.length);
            $options.eq(random).prop('selected', true);

            function add_option(id,text) {
               $('#boilerselctor').append($('<option>', {value:id}).text(text));
            }
            add_option("test_sim","Test Simulation");
            add_option("sandbox","Sandbox");
            add_option("lab1a","Lab 1a");
            add_option("lab1b","Lab 1b");
            add_option("lab1c","Lab 1c");
            add_option("lab1d","Lab 1d");

            //if(localStorageAvailable) {
            //   var url=localStorage.getItem('serverURL');
            //   if(url!=null) {
            //      $('#serverURL').val(url);
            //   }
            //}
            
          

            ace.require("ace/ext/language_tools"); //setup the text editor
            editor = ace.edit("editor");
      
            editor.setOptions({
               enableBasicAutocompletion: true,
               enableSnippets: false,
               enableLiveAutocompletion: false,
               showPrintMargin: false
            });
      
            editor.setTheme("ace/theme/eclipse"); 
            editor.getSession().setMode("ace/mode/python");
            
            /*editor.getSession().setValue("nextTime = 1\ntoggle = 0\ndef init(robot_model):\n    global ghost\n    ghost=kviz.add_ghost('myGhost')\n    kviz.set_color(ghost,[1,0,0,0.25],True)\n    q=kviz.get_robot_config()\n    q[8]-=2.0\n    kviz.set_ghost_config(q,'myGhost')\n    kviz.add_text('HUD1',1,1)\n    kviz.update_text('HUD1','hello world')\n\ndef control_loop(t,controller):\n    global nextTime, toggle\n    if t >= nextTime:\n        q = controller.getCommandedConfig()\n        q[8] -= 0.5\n        controller.setMilestone(q)\n        nextTime += 1.0\n        ");
            */
            
            boilerPlateChanged();
                       
            //var editor = CodeMirror( document.getElementById("editor"), { //use codemirror as text editor
            //value: "print 'hello world'\n",
            //mode:  "python",
            //lineNumbers: true,
            //autohint: true,
            //hint: true
            //});

            w2ui.layout.on('resize', function(event) { //make sure three.js canvas resizes when sub-window size changes
               event.onComplete = function () {
                  console.log("resize completed"); 
                  onWindowResize(event);
               }
            });
 
            visPanel=w2ui['layout'].get('main');   
     
            container = document.getElementById("canvas");
            renderer.setClearColor(0x88888888);
            container.appendChild( renderer.domElement );  //attach the three.js renderer to the proper div 


            
            controls=new THREE.TrackballControls( camera, container);
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;
                controls.keys = [ 65, 83, 68 ];
            controls.addEventListener( 'change', render );   
                         
            onWindowResize();
            animate();       
         });

         function runConnected(onconnect)
         {
            if(!isConnected())
            {
               doConnect();

            }
            waitForConnection(1000,onconnect,null);
         }

         function doConnectInternal()
         {
            var URL=$('#serverURL').val();
            console.log("trying to connect to URL: " + URL);
            network = new Network(URL,newSceneArrivedCallback,consoleTextArrivedCallback,consoleTextArrivedCallback);    
            //if(localStorageAvailable)
            //{
            //  localStorage.setItem('serverURL', URL);
            //}
         }
         
         function doConnect()
         {
            if(isConnected()) {
               waitForDisconnection(function() {doConnectInternal();});
            }
            else 
               doConnectInternal();
         }
   
         function sendCode() //send python code back to server
         {
            console.log("got request to send code!\n");
            console.log("trying to send: " + editor.getValue());
            sendMessage("C"+editor.getValue());
            //sendMessage("hello world");
         }
            
         function onWindowResize( event )
         {
            console.log("onWindowResize");
         
            mWidth= visPanel.width-11; //account for 5px padding on each side
            mHeight=visPanel.height-11;
         
            console.log("width: " + mWidth + " height: " + mHeight);
            renderer.setSize(mWidth,mHeight );
            camera.aspect =mWidth/ mHeight;
               
            camera.updateProjectionMatrix();         
            controls.handleResize();
            render();
         }       
         
         function consoleTextArrivedCallback(data)
         {
            console.log("new console text has arrived: " + data);
            
            //TODO: add it to text window here. 
            var textArea=document.getElementById("myTextarea");
            ;
            var n = data.indexOf("\n");
            if(n!=-1)
            {
               data = data.slice(0, n+1) + "> " + data.slice(n+1);         
               
            }
            textArea.value+=data;
            //var currentText=textArea.val();
          
            //textArea.val(currentText+data);
            textArea.scrollTop = textArea.scrollHeight;
         }
         
         function consoleErrorArrivedCallback(data)
         {            
            console.log("new console error has arrived: " + data);
            
            //TODO: add it to text window here. 
            var textArea=document.getElementById("myTextarea");
            textArea.value+=data;
            //var currentText=textArea.val();
          
            //textArea.val(currentText+data);
            textArea.scrollTop = textArea.scrollHeight;
         }
  
         function newSceneArrivedCallback(data)
         {   
            console.log("new scene has arrived!");
         
            var dataJ=JSON.parse(data); 

            //need to determine if full scene or just transforms
            var isFullScene=dataJ.metadata.fullscene;
         
            console.log("full scene is: " + isFullScene);
         
            if(isFullScene)
            {        
               var t0 = performance.now();
            
               //loader.setTexturePath( scope.texturePath );

            	var scope = this;
               var geometry;
               var material;
               
		         scene.traverse( function ( child ) { //make sure to dispose all old objects
   			      if ( child.geometry !== undefined ) child.geometry.dispose();
	               if ( child.material !== undefined ) child.material.dispose();
               } );
               scene=null;
            
               scene = loader.parse( dataJ );
               //clear anything named _text_overlay_X
               function remove_text(index) {
                  if(this.id.startsWith("_text_overlay_")) {
                     console.log("Removing text item "+this.id);
                     this.remove();
                  }
               }
               //TODO: make this optional?
               var axisHelper = new THREE.AxisHelper( 0.2 );
               scene.add( axisHelper );

               $('#canvas').children().each(remove_text);
               var t1 = performance.now();
               console.log("Call to load scene " + (t1 - t0) + " milliseconds.")
               //scene.traverse ( function (child) {
               //  console.log("found: " + child.name);
               //});
            }
            else //just apply transforms
            {
               var t0 = performance.now();
               var sceneObjects=dataJ.object;
           
               for(i=0; i<sceneObjects.length; i++)
               {  
                  //console.log("Update requested to: " + sceneObjects[i].name);
                  //console.log("  new matrix is: " + sceneObjects[i].matrix);
           
                  var object = scene.getObjectByName(sceneObjects[i].name, true );
                  if(object != null)
                  { 
                    //console.log("  we found \"" + sceneObjects[i].name + "\" in the Three.js scene");
                                   
                    object.matrixAutoUpdate=false;
                    object.matrixWorldNeedsUpdate=true;
                  
                    var m=sceneObjects[i].matrix;
               
                    object.matrix.set(m[0],m[4],m[8],m[12],m[1],m[5],m[9],m[13],m[2],m[6],m[10],m[14],m[3],m[7],m[11],m[15]);

                  } 
               } 
               var t1 = performance.now();
               console.log("Call to load tranforms " + (t1 - t0) + " milliseconds.");
            }
            
            var t1 = performance.now();

            var rpc =dataJ.RPC;
            for(i=0; i<rpc.length; i++)
            {  
               var request=rpc[i];
               if(request.type == "set_color") 
               {
                  var object_name=request.object;
                  var rgba=request.rgba;
                  var recursive=request.recursive;
                                                             
                  console.log("set_color requested. object: " + object_name + " rgba: " + rgba); 
                  
                             
                  var object = scene.getObjectByName(object_name, true );
                  if(object != null)
                  { 
                     console.log("we found the object in the tree");
                     //if(typeof object.material !== 'undefined')
                     //{
                      //  console.log("first checking if we've working this this material before");
                                                                        
                        if(recursive==false)
                        {
                           if(typeof object.userData.customSingleMaterialSetup === 'undefined')
                           {      
                              if((typeof object.geometry) !== 'undefined' && object.geometry.type == 'LineGeometry')
                              {
                                 basicMaterial = new THREE.LineBasicMaterial();                         
                              }
                              else
                                 basicMaterial = new THREE.MeshPhongMaterial();
                              
                              object.material=basicMaterial;      
                              
                              object.userData.customSingleMaterialSetup=true;
                           }
                        }
                        else
                        {
                           if(typeof object.userData.customSharedMaterialSetup === 'undefined')
                           {                          
                              if((typeof object.geometry) !== 'undefined' && object.geometry.type == 'LineGeometry')
                              {
                                 basicMaterial = new THREE.LineBasicMaterial();                         
                              }
                              else
                                 basicMaterial = new THREE.MeshPhongMaterial();
                              
                              object.material=basicMaterial;      
                              
                              object.userData.customSharedMaterialSetup=true;
                              
                              object.traverse( function ( child ) { 
                              if (typeof child.material !== 'undefined') 
                                 child.material=object.material;
                              } );
                           }                        
                        }                    
                  
                        object.material.color.setRGB(rgba[0],rgba[1],rgba[2]);
                        if(rgba[3]!=1.0)
                        {
                           object.material.transparent=true;
                           object.material.opacity=rgba[3];
                        }
                        else
                        {
                           object.material.transparent=false;
                        }
                        console.log("succesfully set link color");
                     //}
                     //else
                     //{
                     //   console.log("ERROR: no material associated with object: " + object_name);  
                     //   alert("ERROR: kviz.set_color is trying to set an object with no material");
                     //}
                  }
               }
               else if(request.type == "add_ghost") 
               {
                  var object_name=request.object;
                  var prefix=request.prefix_name;
                                                             
                  console.log("add_ghost requested. object: " + object_name + " prefix: " + prefix); 
                                               
                  var object = scene.getObjectByName(object_name, true );
                  if(object != null)
                  { 
                     console.log("we found the object in the tree");
                    
                     var clone_object=object.clone(true);
                     scene.add(clone_object);
                     
                     clone_object.traverse( function ( child ) { 
                              if (typeof child.name !== 'undefined') 
                                 child.name=prefix+child.name;
                              } );
                  }
               }
               else if(request.type == "set_position")
               {                 
                  console.log("got a set_position RPC request for: " + request.object);
                  var object = scene.getObjectByName(request.object, true );
                  if(object != null)
                  {            
                    object.matrixAutoUpdate=false;
                    object.matrixWorldNeedsUpdate=true;
                  
                    var m=request.matrix;     
                    object.matrix.set(m[0],m[1],m[2],m[3],m[4],m[5],m[6],m[7],m[8],m[9],m[10],m[11],m[12],m[13],m[14],m[15]);
                  } 
                  else
                     console.log("  couldn't find object: " + request.object);
               }
               else if(request.type == "add_text")
               {
                  console.log("RPC to add text!");     
                  var text2 = document.createElement('div');
                  text2.style.position = 'absolute';
                  text2.id="_text_overlay_"+request.name;
                  //text2.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
                  //text2.style.width = 100;
                  //text2.style.height = 100;
                  //text2.style.backgroundColor = "blue";
                  if(request.text!=null)
                     text2.innerHTML = request.text;
                     
                  text2.style.top = request.x + '%';
                  text2.style.left = request.y + '%';
                  document.getElementById("canvas").appendChild(text2);
               }
               else if(request.type == "update_text")
               {
                  var text2 = document.getElementById("_text_overlay_"+request.name);
                  text2.innerHTML = request.text;
               }
               else if(request.type == "add_sphere")
               {
                  console.log("RPC to add sphere!"); 
                  var geometry = new THREE.SphereGeometry(1.0,20,20);
                  var material = new THREE.MeshPhongMaterial( {color: 0xAA0000} );
                  var sphere = new THREE.Mesh( geometry, material );
                  
                  sphere.scale.x=request.r;
                  sphere.scale.y=request.r;
                  sphere.scale.z=request.r;
                  
                  sphere.name=request.name;
                  sphere.position.set(request.x,request.y,request.z);
                  scene.add( sphere );                     
               }
               else if(request.type == "update_sphere")
               {                 
                  var sphere = scene.getObjectByName(request.name, true );
                  if(sphere != null)
                  { 
                     sphere.position.set(request.x,request.y,request.z);
                     if(request.r!=-1)
                     {
                        sphere.scale.x=request.r;
                        sphere.scale.y=request.r;
                        sphere.scale.z=request.r;
                     }
                  }
                  else
                     console.log("couldn't find sphere named: " + request.name);
               }
               else if(request.type == "add_line")
               {
                  console.log("RPC to add line!"); 
                  var geometry = new THREE.Geometry();
                  
                  geometry.vertices.push(new THREE.Vector3(request.x1,request.y1,request.z1));
                  geometry.vertices.push(new THREE.Vector3(request.x2,request.y2,request.z2));
                  geometry.dynamic  = true;
                     
                  var material = new THREE.LineBasicMaterial( {color: 0xAA0000} );
                  var line = new THREE.Line( geometry, material );
                  line.name=request.name;
                   
                  scene.add( line );                     
               }
               else if(request.type == "update_line")
               {                 console.log("RPC to update line");
                  var line = scene.getObjectByName(request.name, true );
                  if(line != null)
                  { 
                     line.geometry.vertices[0]=new THREE.Vector3(request.x1,request.y1,request.z1);
                     line.geometry.vertices[1]=new THREE.Vector3(request.x2,request.y2,request.z2);
                     line.geometry.verticesNeedUpdate = true;
                  }
                  else
                     console.log("couldn't find line named: " + request.name);
               } 
               else {
                  console.log("Invalid request: "+request.type);
               }
            }
            var t2 = performance.now();
            if(rpc.length > 0)
            {
               console.log("Call to do RPC's " + (t2 - t1) + " milliseconds.")
            }
            else
               console.log("no RPC's present");
            
            data=null;
            dataJ=null;
            rpc=null;
            
           
            var t0 = performance.now();
            render();
            var t1 = performance.now();
            console.log("Time to render " + (t1 - t0) + " milliseconds.")
            console.log("finished processing message");
            if(freeRun)
              requestAdvance();
         }
      
         function animate()
         {
            requestAnimationFrame( animate  );
            controls.update();
         }
  
         function render()
         {     
            //stats.begin();
            renderer.render( scene, camera );
            //stats.end();
         }
      </script>
   </body>
</html>
